# -*- coding: utf-8 -*-
"""base.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pA31SLAqVz4qrxWzD56ol2Lv6yfnHW9-
"""

import pandas as pd
import numpy as np
import folium
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import requests
import json

class HackathonHomelessModel:
    """
    Quick hackathon model for San Diego homeless services gap analysis
    """

    def __init__(self):
        self.model = RandomForestRegressor(n_estimators=50, random_state=42)
        self.scaler = StandardScaler()

    def generate_mock_data(self):
        """
        Generate realistic mock data for San Diego County
        Based on actual patterns but synthetic for hackathon speed
        """
        # San Diego regions with approximate coordinates
        regions = [
            {'name': 'Downtown', 'lat': 32.7157, 'lon': -117.1611, 'homeless_density': 'high'},
            {'name': 'East County', 'lat': 32.7503, 'lon': -116.9930, 'homeless_density': 'medium'},
            {'name': 'North County', 'lat': 33.1581, 'lon': -117.3506, 'homeless_density': 'low'},
            {'name': 'South Bay', 'lat': 32.5821, 'lon': -117.0440, 'homeless_density': 'medium'},
            {'name': 'Mid-City', 'lat': 32.7353, 'lon': -117.1473, 'homeless_density': 'high'},
            {'name': 'Oceanside', 'lat': 33.1959, 'lon': -117.3795, 'homeless_density': 'medium'},
            {'name': 'Escondido', 'lat': 33.1192, 'lon': -117.0864, 'homeless_density': 'medium'},
            {'name': 'Chula Vista', 'lat': 32.6401, 'lon': -117.0842, 'homeless_density': 'low'},
            {'name': 'National City', 'lat': 32.6781, 'lon': -117.0992, 'homeless_density': 'high'},
            {'name': 'La Mesa', 'lat': 32.7678, 'lon': -117.0231, 'homeless_density': 'low'}
        ]

        data = []
        zip_codes = [92101, 92102, 92103, 92104, 92105, 92106, 92107, 92108, 92109, 92110,
                    92111, 92112, 92113, 92114, 92115, 92116, 92117, 92118, 92119, 92120,
                    92121, 92122, 92123, 92124, 92126, 92127, 92128, 92129, 92130, 92131]

        for i, region in enumerate(regions):
            # Generate 3 zip codes per region
            for j in range(3):
                zip_code = zip_codes[i*3 + j] if i*3 + j < len(zip_codes) else 92199

                # Set homeless counts based on density
                if region['homeless_density'] == 'high':
                    homeless_count = np.random.randint(150, 400)
                    sheltered = np.random.randint(50, 150)
                elif region['homeless_density'] == 'medium':
                    homeless_count = np.random.randint(50, 150)
                    sheltered = np.random.randint(20, 80)
                else:
                    homeless_count = np.random.randint(10, 50)
                    sheltered = np.random.randint(5, 25)

                unsheltered = homeless_count - sheltered

                # Generate correlated features
                median_income = np.random.randint(30000, 120000)
                poverty_rate = max(5, 50 - (median_income - 30000) / 2000)

                # Service capacity (often inadequate)
                service_capacity = int(homeless_count * np.random.uniform(0.3, 0.8))
                num_services = np.random.randint(1, 8)

                data.append({
                    'zip_code': zip_code,
                    'region': region['name'],
                    'lat': region['lat'] + np.random.uniform(-0.05, 0.05),
                    'lon': region['lon'] + np.random.uniform(-0.05, 0.05),
                    'homeless_count': homeless_count,
                    'sheltered': sheltered,
                    'unsheltered': unsheltered,
                    'service_capacity': service_capacity,
                    'num_services': num_services,
                    'median_income': median_income,
                    'poverty_rate': poverty_rate,
                    'unemployment_rate': np.random.uniform(3, 15),
                    'mental_health_services': np.random.randint(0, 3),
                    'substance_abuse_services': np.random.randint(0, 2),
                    'job_training_centers': np.random.randint(0, 2),
                    'healthcare_facilities': np.random.randint(0, 4),
                    'median_rent': np.random.randint(1200, 3500),
                    'population': np.random.randint(5000, 50000)
                })

        return pd.DataFrame(data)

    def calculate_service_gaps(self, df):
        """
        Calculate various service gap metrics
        """
        # Basic capacity gap
        df['capacity_gap'] = df['homeless_count'] - df['service_capacity']

        # Services per homeless person
        df['services_per_homeless'] = df['num_services'] / df['homeless_count']

        # Comprehensive service score (0-100)
        df['mental_health_score'] = (df['mental_health_services'] / df['homeless_count'] * 1000).clip(0, 100)
        df['substance_abuse_score'] = (df['substance_abuse_services'] / df['homeless_count'] * 1000).clip(0, 100)
        df['job_training_score'] = (df['job_training_centers'] / df['homeless_count'] * 1000).clip(0, 100)
        df['healthcare_score'] = (df['healthcare_facilities'] / df['homeless_count'] * 1000).clip(0, 100)

        # Overall need score (higher = more need)
        df['need_score'] = (
            df['capacity_gap'] * 0.4 +
            (100 - df['mental_health_score']) * 0.2 +
            (100 - df['substance_abuse_score']) * 0.15 +
            (100 - df['job_training_score']) * 0.15 +
            (100 - df['healthcare_score']) * 0.1
        )

        # Normalize need score to 0-100
        df['need_score'] = ((df['need_score'] - df['need_score'].min()) /
                           (df['need_score'].max() - df['need_score'].min()) * 100)

        return df

    def train_predictive_model(self, df):
        """
        Train model to predict service needs
        """
        features = ['homeless_count', 'unsheltered', 'poverty_rate',
                   'unemployment_rate', 'median_income', 'median_rent',
                   'num_services', 'service_capacity', 'population']

        X = df[features]
        y = df['need_score']

        # Scale features
        X_scaled = self.scaler.fit_transform(X)

        # Train model
        self.model.fit(X_scaled, y)

        # Get feature importance
        feature_importance = pd.DataFrame({
            'feature': features,
            'importance': self.model.feature_importances_
        }).sort_values('importance', ascending=False)

        return feature_importance

    def identify_priority_areas(self, df, top_n=5):
        """
        Identify top priority areas for intervention
        """
        priority_areas = df.nlargest(top_n, 'need_score')[
            ['zip_code', 'region', 'need_score', 'homeless_count',
             'capacity_gap', 'num_services', 'lat', 'lon']
        ].copy()

        return priority_areas

    def recommend_interventions(self, priority_areas, df):
        """
        Recommend specific interventions for each priority area
        """
        recommendations = []

        for _, area in priority_areas.iterrows():
            zip_code = area['zip_code']
            area_data = df[df['zip_code'] == zip_code].iloc[0]

            interventions = []

            # Emergency shelter needs
            if area_data['capacity_gap'] > 50:
                interventions.append({
                    'type': 'Emergency Shelter',
                    'priority': 'High',
                    'capacity_needed': int(area_data['capacity_gap'] * 0.7),
                    'rationale': f"Gap of {area_data['capacity_gap']} people"
                })

            # Mental health services
            if area_data['mental_health_score'] < 30:
                interventions.append({
                    'type': 'Mental Health Services',
                    'priority': 'High',
                    'capacity_needed': max(1, int(area_data['homeless_count'] / 100)),
                    'rationale': f"Low mental health service coverage"
                })

            # Substance abuse treatment
            if area_data['substance_abuse_score'] < 40:
                interventions.append({
                    'type': 'Substance Abuse Treatment',
                    'priority': 'Medium',
                    'capacity_needed': max(1, int(area_data['homeless_count'] / 150)),
                    'rationale': f"Limited substance abuse services"
                })

            # Job training
            if area_data['job_training_score'] < 35 and area_data['unemployment_rate'] > 8:
                interventions.append({
                    'type': 'Job Training Center',
                    'priority': 'Medium',
                    'capacity_needed': 1,
                    'rationale': f"High unemployment ({area_data['unemployment_rate']:.1f}%)"
                })

            recommendations.append({
                'zip_code': zip_code,
                'region': area_data['region'],
                'interventions': interventions,
                'total_cost_estimate': sum([i['capacity_needed'] for i in interventions]) * 500000  # $500k per facility
            })

        return recommendations

    def create_dashboard_map(self, df, priority_areas):
        """
        Create interactive map for dashboard
        """
        # Create base map
        m = folium.Map(location=[32.7157, -117.1611], zoom_start=10)

        # Add all areas with color coding
        for _, row in df.iterrows():
            # Color based on need score
            if row['need_score'] > 75:
                color = 'red'
                fill_color = 'red'
            elif row['need_score'] > 50:
                color = 'orange'
                fill_color = 'orange'
            else:
                color = 'green'
                fill_color = 'green'

            folium.CircleMarker(
                location=[row['lat'], row['lon']],
                radius=max(5, row['homeless_count'] / 20),
                popup=f"""
                <b>Zip Code: {row['zip_code']}</b><br>
                Region: {row['region']}<br>
                Need Score: {row['need_score']:.1f}<br>
                Homeless Count: {row['homeless_count']}<br>
                Service Gap: {row['capacity_gap']}<br>
                Services: {row['num_services']}
                """,
                color=color,
                fill=True,
                fillColor=fill_color,
                fillOpacity=0.7
            ).add_to(m)

        # Highlight priority areas
        for _, area in priority_areas.iterrows():
            folium.CircleMarker(
                location=[area['lat'], area['lon']],
                radius=20,
                popup=f"<b>PRIORITY AREA</b><br>Zip: {area['zip_code']}<br>Need Score: {area['need_score']:.1f}",
                color='black',
                weight=3,
                fill=False
            ).add_to(m)

        # Add legend
        legend_html = '''
        <div style="position: fixed;
                    bottom: 50px; left: 50px; width: 150px; height: 90px;
                    background-color: white; border:2px solid grey; z-index:9999;
                    font-size:14px; padding: 10px">
        <p><b>Need Level</b></p>
        <p><i class="fa fa-circle" style="color:red"></i> High (75+)</p>
        <p><i class="fa fa-circle" style="color:orange"></i> Medium (50-75)</p>
        <p><i class="fa fa-circle" style="color:green"></i> Low (<50)</p>
        </div>
        '''
        m.get_root().html.add_child(folium.Element(legend_html))

        return m

    def create_analysis_charts(self, df, priority_areas, feature_importance):
        """
        Create analysis charts for presentation
        """
        # 1. Need Score Distribution
        fig1 = px.histogram(df, x='need_score', nbins=15,
                           title='Distribution of Service Need Scores Across San Diego County')
        fig1.update_layout(xaxis_title='Need Score', yaxis_title='Number of Areas')

        # 2. Service Gap by Region
        fig2 = px.box(df, x='region', y='capacity_gap',
                     title='Service Capacity Gap by Region')
        fig2.update_layout(xaxis_title='Region', yaxis_title='Capacity Gap (People)')

        # 3. Feature Importance
        fig3 = px.bar(feature_importance.head(8), x='importance', y='feature',
                     orientation='h', title='Most Important Factors for Service Need')
        fig3.update_layout(xaxis_title='Importance Score', yaxis_title='Feature')

        # 4. Priority Areas Analysis
        fig4 = px.scatter(priority_areas, x='homeless_count', y='need_score',
                         size='capacity_gap', color='region',
                         title='Priority Areas: Homeless Count vs Need Score')
        fig4.update_layout(xaxis_title='Homeless Count', yaxis_title='Need Score')

        return fig1, fig2, fig3, fig4

    def generate_executive_summary(self, df, priority_areas, recommendations):
        """
        Generate executive summary for presentation
        """
        total_homeless = df['homeless_count'].sum()
        total_gap = df['capacity_gap'].sum()
        avg_need = df['need_score'].mean()

        summary = f"""
        🏠 SAN DIEGO HOMELESS SERVICES GAP ANALYSIS
        ==========================================

        📊 KEY FINDINGS:
        • Total Homeless Population: {total_homeless:,} people
        • Total Service Capacity Gap: {total_gap:,} people
        • Average Need Score: {avg_need:.1f}/100
        • Areas Analyzed: {len(df)} zip codes

        🚨 TOP 5 PRIORITY AREAS:
        """

        for i, (_, area) in enumerate(priority_areas.iterrows()):
            summary += f"\n   {i+1}. {area['region']} (Zip {area['zip_code']})"
            summary += f"\n      Need Score: {area['need_score']:.1f} | Gap: {area['capacity_gap']} people"

        summary += f"\n\n💰 INVESTMENT RECOMMENDATIONS:"
        total_cost = sum([r['total_cost_estimate'] for r in recommendations])
        summary += f"\n   • Total Estimated Investment: ${total_cost:,}"
        summary += f"\n   • Primary Focus: Emergency Shelter + Mental Health"
        summary += f"\n   • Expected Impact: Serve {total_gap * 0.7:.0f} additional people"

        return summary

def run_hackathon_demo():
    """
    Main function to run the complete analysis
    """
    print("🚀 Starting San Diego Homeless Services Gap Analysis...")

    # Initialize model
    model = HackathonHomelessModel()

    # Generate and prepare data
    print("📊 Generating data...")
    df = model.generate_mock_data()
    df = model.calculate_service_gaps(df)

    # Train predictive model
    print("🤖 Training predictive model...")
    feature_importance = model.train_predictive_model(df)

    # Identify priority areas
    print("🎯 Identifying priority areas...")
    priority_areas = model.identify_priority_areas(df)

    # Generate recommendations
    print("💡 Generating recommendations...")
    recommendations = model.recommend_interventions(priority_areas, df)

    # Create visualizations
    print("📈 Creating visualizations...")
    map_viz = model.create_dashboard_map(df, priority_areas)
    charts = model.create_analysis_charts(df, priority_areas, feature_importance)

    # Generate summary
    summary = model.generate_executive_summary(df, priority_areas, recommendations)

    print("\n" + "="*60)
    print(summary)
    print("="*60)

    # Save map
    map_viz.save('san_diego_homeless_services_map.html')
    print("\n📍 Interactive map saved as 'san_diego_homeless_services_map.html'")

    return {
        'model': model,
        'data': df,
        'priority_areas': priority_areas,
        'recommendations': recommendations,
        'map': map_viz,
        'charts': charts,
        'summary': summary
    }

if __name__ == "__main__":
    results = run_hackathon_demo()